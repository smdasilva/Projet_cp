\chapter{Architecture/Technique}


\section{Dicom}
\subsection{Bibliothèques}
Afin de pouvoir lire des fichier au format .dcm, nous avons du trouver une bibliothèque en java.
Il y a deux parties importantes dans un fichier dicom : l'image et les informations relatives à l'examen.
Nous nous sommes d'abord tournés vers dcm4che, mais nous nous sommes rapidement apercus que cette bibliothèque, en plus de ne pas être facile d'utilisation, n'était pas compatible avec android. Nous avons alors trouvé la bibliothèque pixelmed, beaucoup plus intuitive. La récupération des informations contenues dans un dicom à l'aide de cette bibliothèque était très facile, mais le récupération de l'image ne fonctionnait pas sous android. Nous avons alors décidé de conserver pixelmed pour les informations et d'utiliser DroidDicomViewer pour l'image.

\subsection{Affichage de l'image}
Afin de pouvoir changer le contraste de l'image en utilisant l'echelle de Hounsfield, nous avons implémenté un transcriber capable de transformer l'information de l'image suivant les paramètres de l'echelle en données affichable par la vue.
- Système de visualisation (Hounsfield)

\section{Moteur de réseau}
% on a un moteur de réseau ???

\section{Gestion de la mémoire}
\subsection{Le système de cache}
Afin d'éviter de surcharger la mémoire limitée de l'appareil, nous avons iplémenté un système de cache.
Il se base sur l'algorithme LRU déjà implémenté au sein d'android. La classe LruCache stocke des lignes de cache chargées de lire de facon asynchrone les fichiers dicom pour générer les slices de l'examen. L'accès à la slice n'est alors permis que lorsque le fichier a été lu.
Lorsque la taille maximum du cache est atteinte, LruCache se charge d'éliminer le plus ancien.
La taille de ce cache est configurable au sein du code pour permettre de l'adapter au besoin.

\subsection{Le masque}
L'économie de la mémoire est un enjeu très important, encore plus présent dans ce cas
puisqu'il s'agit d'une application sur une tablette.\\
Le masque représente les zones sélectionnées
par l'utilisateur, soit une matrice de booléens. Cependant, stocker en plus tout une matrice est coûteux en mémoire,
étant donné que les éléments de la matrice sont soit sélectionnés ou non \\
(true/false), la base de la solution repose sur le fait de ne stocker que les
\\coordonnées des pixels sélectionnés. Afin d'économiser encore plus au lieu de stocker 2 entiers (soit avec un tableau de longueur 2,
un objet de type "Pair", etc.), on utilise la fonction de \textbf{Cantor} qui code deux entiers naturels en un seul et \textbf{unique}.
L'interface "Mask" possède deux méthodes get/setPixel prenant en paramètre les coordonnées $(x,y)$ et la méthode prend en plus un booléen\\
signalant si le pixel est sélectionné ou non.
La classe "InfiniteMask" implémentant l'interface "Mask" repose sur le principe suivant:
\vspace{0.2cm}

\begin{itemize}
\item[\textbf{setPixel(($x,y,$ isselected)}] de l'extérieur cette méthode change la valeur du pixel, mais dans le cas d'InfiniteMask
cela utilise la fonction de Cantor ainsi $f(x,y)  \mapsto z$ (l'opération est en $ O(1)$. Si la valeur "isselected" est vraie cela stocke l'entier $z$, sinon
$z$ est retiré. De plus, la structure de données stockant les entiers est une \textbf{Set} donc n'acceptant \underline{aucun doublon}.
\vspace*{0.2cm}
\item[\textbf{getPixel($x,y$)}] cela teste si l'entier $z$ obtenu est stocké dans le masque.
\end{itemize}

\newpage
De l'extérieur, l'utilisateur a l'impression de manipuler une matrice de booléens tout à fait classique.
Au niveau de l'économie de mémoire, au lieu de stocker tout une matrice on ne stocke quelques entiers
(excepté pour des tests de montés en charge), la majeure partie du temps il y aura une grande majorité de pixels non sélectionnés.
Dans le pire des cas, tous les pixels sélectionnés pour une matrice $m\times n$, seront stockés $m\times n$ entiers.
